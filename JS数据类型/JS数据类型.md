# JS数据类型
* 数据类型
  > 基础数据类型
    > > + 基础数据类型存储在栈内存，被引用或拷贝时会创建一个完全相等的变量
    > > + String、Boolean、Number、Null、Undefined、Symbol、Biglnt

  > 引用数据类型
    > > + 引用类型存储在堆内存，存储的是地址，多个引用指向同一个地址
    > > + Object、Array、Function、RegExp、Date、Math

* 判断数据类型
  > typeof
    > > + typeof 可以判断基础数据类型（null除外）
    > > + 但是引用数据类型中，除了function，其他的也无法判断

  > instanceof 
    > > + instanceof 可以准确地判断复杂数据类型
    > > + 但是不能判断基础数据类型

  > Object.prototype.toString.Call()
    > > + Object.prototype.toString.Call 可以准确的判断出引用数据和基础数据
  
* 数据类型转换
  > 强制类型转换
  > > + Number()  
  > > > - 1. 如果是布尔值，true 和 false 分别被转换为 1 和 0  
  > > > - 2. 如果是数字，返回自身  
  > > > - 3. 如果是 null，返回 0  
  > > > - 4. 如果是 undefined，返回 NaN  
  > > > - 5. 如果是字符串，遵循以下规则：如果字符串中只包含数字（或者是 0X / 0x 开头的十六进制数字字符串，允许包含正负号），则将其转换为十进制；如果字符串中包含有效的浮点格式，将其转换为浮点数值；如果是空字符串，将其转换为 0；如果不是以上格式的字符串，均返回 NaN  
  > > > - 6. 如果是 Symbol，抛出错误  
  > > > - 7. 如果是对象，并且部署了 [Symbol.toPrimitive] ，那么调用此方法，否则调用对象的 valueOf() 方法，然后依据前面的规则转换返回的值；如果转换的结果是 NaN ，则调用对象的 toString() 方法，再次依照前面的顺序转换返回对应的值  
  > > + String()  
  > > > - 1. null转换为"null",undefined转换为"undefined",true转换为""true",数字转为相应的字符串，字符串转换后还是原来的值
  > > > - 2. 如果是对象，返回一个类型字符串；如果是数组，返回该数组的字符串形式
  > > + Boolean()  
  > > > - 除了 undefined、 null、 false、 ''、 0（包括 +0，-0）、 NaN 转换出来是 false，其他都是 true  
  > > + parseInt()  
  > > > - 1. 忽略字符串前面的空格，直至找到第一个非空字符
  > > > - 2. 如果第一个字符不是数字符号或者负号，返回NaN
  > > > - 3. 如果第一个字符是数字，则继续解析直至字符串解析完毕或者遇到一个非数字符号为止
  > > > - 4. 如果上步解析的结果以0开头，则将其当作八进制来解析；如果以x开头，则将其当作十六进制来解析
  > > > - 5. 如果指定radix参数，则以radix为基数进行解析
  > > + parseFloat()  
  > > > - 它的规则与parseInt基本相同，但也有点区别：字符串中第一个小数点符号是有效的，另外parseFloat会忽略所有前导0，如果字符串包含一个可解析为整数的数，则返回整数值而不是浮点数值
  > > + toString()  
  > > > - 1. null转换为"null",undefined转换为"undefined",true转换为""true"。数字的字符串化遵循通用规则，那些极小和极大的数字使用指数形式
  > > > - 2. 普通对象toString()返回内部属性[[Class]]的值，如"[object Object]"
  > > > - 3. 数组的默认toString()方法经过了重新定义，将所有单元字符串化以后再用","连接起来
  > + 隐式类型转换